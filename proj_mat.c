
void arb_proj_mat(const float *a, const float *b, const float *c, const float *e, float n, float f, float *mat) {
  // I'm not sure this is exactily what is needed if everything is in coordinates relative to the display.
  // He're what I'm trying to implement: http://csc.lsu.edu/~kooima/pdfs/gen-perspective.pdf
  // TODO implement maybe? idk
}

void screen_proj_mat(float left, float right, float top, float bottom, float far, float *eye, float *mat) {
  // I think this'll work better. It'll only work if everything is behind the xy plane in the -z direction.
  // This is basically an implementation of the matrix generated by glFrustrum from OpenGL 1.0. See https://www.opengl.org/sdk/docs/man2/xhtml/glFrustum.xml
  // The difference is that everything is translated to camera space first, then the perspective transform is applied.
  // Link to math: https://www.wolframalpha.com/input/?i=[[%282*n%29%2F%28r-l%29,0,%28r%2Bl%29%2F%28r-l%29,0],[0,%282*n%29%2F%28t-b%29,%28t%2Bb%29%2F%28t-b%29,0],[0,0,-%28f%2Bn%29%2F%28f-n%29,-%282*f*n%29%2F%28f-n%29],[0,0,-1,0]]*[[1,0,0,X],[0,1,0,Y],[0,0,1,Z],[0,0,0,1]]

  // Translate the display bounds to eye space.
  right -= eye[0];
  left -= eye[0];
  top -= eye[1];
  bottom -= eye[1];
  far -= eye[2];
  float near = -eye[2];

  // row major
  // frustrum * translate
  // I haven't tested this crazy thing yet.
  mat[0] = 2*near/(right-left);
  mat[1] = 0.0;
  mat[2] = (right+left)/(right-left);
  mat[3] = (-2*near*eye[0]-(left+right)*eye[2])/(right-left);

  mat[4] = 0.0;
  mat[5] = 2*near/(top-bottom);
  mat[6] =(bottom+top)/(top-bottom);
  mat[7] =(-2*near*eye[1]-(bottom+top)*eye[2])/(top-bottom);

  mat[8] = 0.0;
  mat[9] = 0.0;
  mat[10] = (-far-near)/(far-near);
  mat[11] = ((far+near)*eye[2]-2*far*near)/(far-near);

  mat[12] = 0.0;
  mat[13] = 0.0;
  mat[14] = -1.0;
  mat[15] = eye[2];




}
